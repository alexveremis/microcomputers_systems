PART_A:
		IN 10H			;DISABLE MEMORY PROTECTION
		LXI H,0900H		;START OF MEMORY STORAGE
		MVI B,00H		;SET INITIAL VALUES TO B
		MVI A,00H		;AND A

NUMS_IN_MEM:				
		MOV M,B		;B HAS THE APPROPRIATE NUMBER TO BE
					;STORED
		INR A			;IF A == 0, THEN 256 HAVE BEEN 	
		CPI 00H		;ASSIGNED TO MEMORY AND PART_A IS
		JZ PART_B		;FINISHED, PART_B STARTS
		INX H			;ELSE "POINT" TO THE NEXT MEMORY 
					;STORAGE POSITION
		INR B			;B += 1, NEXT APPROPRIATE NUMBER	
		JMP NUMS_IN_MEM	

PART_B:
		LXI H,0900H		
		MVI B,00H
		MVI C,00H
		MVI D,08H		;D TELLS HOW MANY BITS HAVE BEEN 
					;CHECKED UNTIL NOW
COUNT_ONES:
		MOV A,M		;READ NUMBER FROM MEMORY
CHECK_BIT:
		MOV E,A		;E IS USED AS A TEMPORARY VARIABLE
		MOV A,D		;IF ALL BITS OF CURRENT NUMBER
		CPI 00H		;HAVE BEEN CHECKED THEN
		JZ CHECK_NEXT		;CHECK NEXT NUMBER
		MOV A,E		;ELSE
		RAL			;CHECK NEXT BIT THROUGH CARRY
		DCR D			;ONE LESS BIT TO CHECK
		JNC CHECK_BIT		;IF CURRENT BIT != 1 CHECK NEXT
		INX B			;ELSE, BC += 1, INCREASE NUMBER OF
					;ONES
		JMP CHECK_BIT
CHECK_NEXT:
		INX H			;"POINT" TO THE NEXT MEM POSITION
		MOV A,H		;CHECK IF ALL NUMBERS HAVE BEEN 
		CPI 0AH		;READ 
		JZ PART_C		;IF THEY HAVE, PART_C STARTS
		MVI D,08H		;ELSE CHECK NEXT NUMBER
		JMP COUNT_ONES
		
PART_C:
		LXI H,0900H
		MVI D,00H

IN_RANGE:
		MOV A,M		;READ NUMBER FROM MEMORY
		CPI 10H		;IS LESS THAN 10H?
		JC LOOK_NEXT		;YES, CHECK NEXT NUMBER
		CPI 60H		;IS GREATER THAN 60H?
		JNC LOOK_NEXT		;YES, CHECK NEXT NUMBER
		INR D			;NO, D += 1, INCREASE NUMBER OF 
					;DESIRED NUMBERS
LOOK_NEXT:
		INX H			;"POINT" TO THE NEXT NUMBER TO LOOK
		MOV A,H		;CHECK IF ALL NUMBERS HAVE BEEN 
		CPI 0AH		;READ 
		JZ END_PROGRAM		;IF THEY HAVE, THE PROGRAM ENDS
		JMP IN_RANGE		;ELSE CONTINUES LOOP

END_PROGRAM:
		END